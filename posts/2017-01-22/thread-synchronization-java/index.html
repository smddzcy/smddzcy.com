<!doctype html><html lang="en"><head><meta charset="utf-8"><link rel="shortcut icon" href="/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#000000"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="rating" content="General"><link rel="alternate" href="https://smddzcy.com/rss.xml" type="application/rss+xml" title="RSS"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="smddzcy.com"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="skype_toolbar" content="skype_toolbar_parser_compatible"><meta name="renderer" content="webkit|ie-comp|ie-stand"><link rel="manifest" href="/manifest.json"><link rel="canonical" href="/posts/2017-01-22/thread-synchronization-java" />

    <title data-react-helmet="true">Thread Synchronization in Java - Monitors and Atomic Operations</title>
    
    
  <script>window.__NAVI_STATE__={"__navi__":{"requestDataWithoutState":{}}};</script><link href="/static/css/main.6313059b.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="BlogLayout_container__3WeFl"><div class="
        LoadingIndicator_LoadingIndicator__22gHk
        
        undefined
      "></div><header><h3 class="BlogLayout_title__6OZKV"><a href="/" context="[object Object]" class=" ">smddzcy | yet another dev</a></h3></header><main><article><header class="BlogPostLayout_header__2LB8S"><h1 class="BlogPostLayout_title__3g2FG"><a href="/posts/2017-01-22/thread-synchronization-java" context="[object Object]" class=" ">Thread Synchronization in Java - Monitors and Atomic Operations</a></h1><small><time dateTime="Sat, 21 Jan 2017 21:00:00 GMT">January 22, 2017</time> <!-- -->•<!-- --> <ul class="ArticleMeta_tags__VKe_V"><li><a href="/tags/java" context="[object Object]" class=" ">java</a></li><li><a href="/tags/concurrency" context="[object Object]" class=" ">concurrency</a></li><li><a href="/tags/multi-threading" context="[object Object]" class=" ">multi-threading</a></li><li><a href="/tags/thread synchronization" context="[object Object]" class=" ">thread synchronization</a></li><li><a href="/tags/threads" context="[object Object]" class=" ">threads</a></li></ul> <!-- -->•<!-- --> <span>☕️<!-- --> <!-- -->4<!-- --> min read</span></small></header><div class="BlogPostLayout_content__jzLFq"><div><p>Today I’m going to talk about <strong>thread synchronization</strong>. Let’s start with writing a simple multi-threaded counter.</p><pre><code class="language-java" data-language="java" data-highlighted-line-numbers=""><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CounterThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">CounterThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread:%s, counter:%d\\n"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span>\<span class="token punctuation">[</span>\<span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterThread</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterThread</span><span class="token punctuation">(</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>We expect to see a nice incrementation of the count variable, sometimes by the thread 1 and sometimes by the thread 2. Here is the output this code produces:</p><pre><code>Thread:t2, counter:0
Thread:t1, counter:0
Thread:t1, counter:2
Thread:t1, counter:3
Thread:t1, counter:4
Thread:t1, counter:5
Thread:t2, counter:1
Thread:t2, counter:7
Thread:t2, counter:8
Thread:t2, counter:9
Thread:t1, counter:6
</code></pre><p>This is definitely not the outcome we expected. What is wrong with those first 2 lines? Thread <code>t2</code> increases the counter to 1, so the second line should’ve been <code>Thread:t1, counter:1</code>, right?</p><p><strong>NO</strong>.</p><p>In the example above, there is the possibility that both threads access the variable and increment it at the same time. It’s called <strong>race condition</strong>. Because the thread scheduling algorithm can swap between threads at any time; we don’t know the execution order of the threads, and we don’t know when they will try to access the shared data. The result is; multiple threads <em>racing</em> to access and change the data.</p><p>There are many ways to overcome this problem. Here I’ll provide you two of them that I use the most.</p><h3 id="monitors">Monitors</h3><p>In Java, synchronization is built around an internal entity of an object known as <em>intrinsic lock</em> or <em>monitor</em>. Every object has an intrinsic lock associated with it, and Java uses that to synchronize the object.</p><p>If you want to prevent your threads from accessing the shared data at the same time, you can simply use the builtin synchronized keyword.</p><pre><code class="language-java" data-language="java" data-highlighted-line-numbers=""><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CounterThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">CounterThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread:%s, counter:%d\\n"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>The lock object here acts as a physical lock. Whenever a thread accesses the synchronized code:</p><ul><li>If the lock is unlocked, Java automatically locks it and allows the thread to run the code. When the thread finishes its job, Java automatically unlocks the lock.</li><li>If it’s locked, thread just waits its turn.</li></ul><p>Here we used a simple <code>Object</code> as a lock, but Java provides more powerful locks in the <code>java.util.concurrent.locks</code> package. You can check them out if you want.</p><p>We can also use the <code>synchronized</code> keyword on the method itself, like this:</p><pre><code class="language-java" data-language="java" data-highlighted-line-numbers=""><span class="token annotation punctuation">@Override</span>
<span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread:%s, counter:%d\\n"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>But, <strong>it won’t work</strong> with our case. Here is the output:</p><pre><code>Thread:t1, counter:0
Thread:t2, counter:0
Thread:t2, counter:2
Thread:t2, counter:3
Thread:t2, counter:4
Thread:t2, counter:5
Thread:t2, counter:6
Thread:t2, counter:7
Thread:t2, counter:8
Thread:t2, counter:9
Thread:t1, counter:1
</code></pre><p>If we synchronize the method, Java uses the object’s lock. But our threads have their own objects, and <strong>have their own locks</strong>. Here, they don’t really do anything but locking and unlocking two separate locks without knowing about each other. It becomes the same thing as using no locks at all. It only would’ve worked if the threads were trying to access the same object.</p><h3 id="atomic-operations-and-volatile-keyword">Atomic Operations and Volatile Keyword</h3><p>An operation is <em>atomic</em>, (or <em>linearizable</em>, <em>indivisible</em>, <em>uninterruptible</em>) if it appears to the rest of the system to occur instantaneously. An atomic operation cannot stop in the middle: <strong>it either happens completely, or it doesn’t happen at all</strong>. In other words, <a href="http://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect" rel="nofollow noopener noreferrer" target="_blank" context="[object Object]" class=" ">side effects</a> of an atomic operation are not visible until it finishes.</p><p>By default, <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html" rel="nofollow noopener noreferrer" target="_blank" context="[object Object]" class=" "><strong>Java guarantees that reading or writing a variable is an atomic operation</strong></a>, unless the variable is a long or double. If the variable is declared as volatile, reads and writes become atomic even if it’s a <code>long</code> or <code>double</code>.</p><p>So, why didn’t our example <code>count++</code> work in the first place? The reason is <code>++</code> decomposes into 3 operations; reading, incrementing, and writing back. Even though they’re atomic by themselves, it doesn’t prevent a thread from reading the variable while the other thread is incrementing it. To overcome this problem, we can use the atomic implementation of the integer primitive: <code>AtomicInteger</code>. It provides atomic versions of some composite operations, such as <code>getAndIncrement()</code>, <code>incrementAndGet()</code> and <code>getAndSet(value)</code>.</p><pre><code class="language-java" data-language="java" data-highlighted-line-numbers=""><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread:%s, counter:%d\\n"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>Here’s the output:</p><pre><code>Thread:t1, counter:0
Thread:t2, counter:1
Thread:t2, counter:3
Thread:t2, counter:4
Thread:t2, counter:5
Thread:t2, counter:6
Thread:t2, counter:7
Thread:t2, counter:8
Thread:t2, counter:9
Thread:t1, counter:2
</code></pre><p>As you can see, even though both of them could enter the while loop, they couldn’t increase the number at the same time. There are atomic implementations of many primitives. You can find them under the <code>java.util.concurrent.atomic</code> package.</p><p>Next time I’ll be talking about <strong>semaphores</strong>, which allows us to have (at most) N number of threads accessing the same shared state at the same time. Have a great day!</p></div></div><div style="margin-top:3rem"><div id="disqus_thread"></div></div><footer class="BlogPostLayout_footer__2aOsZ"><h3 class="BlogPostLayout_title__3g2FG"><a href="/" context="[object Object]" class=" ">smddzcy | yet another dev</a></h3><div class="
      Bio_Bio__3ifbk
      BlogPostLayout_bio__3d60S
    "><img src="https://pbs.twimg.com/profile_images/781276128673689600/tGOdd3qK_400x400.jpg" alt="Me"/><div><div>software engineer, web enthusiast. shares articles, tutorials and his thoughts on various things.</div><div><a href="https://linkedin.com/in/smddzcy" title="LinkedIn" rel="nofollow noopener noreferrer" target="_blank" style="margin-right:5px">LinkedIn</a>•<a href="https://github.com/smddzcy" title="GitHub" rel="nofollow noopener noreferrer" target="_blank" style="margin:0 5px">GitHub</a>•<a href="https://twitter.com/smddzcy" title="Twitter" rel="nofollow noopener noreferrer" target="_blank" style="margin:0 5px">Twitter</a>•<a href="/cv" title="CV" style="margin:0 5px">CV</a></div></div></div><section class="BlogPostLayout_links__2NwEx"><a class=" " href="/posts/2017-02-08/functional-programming-a-beginners-view" context="[object Object]">← <!-- -->Functional Programming - A Beginner&#x27;s View</a><a class="BlogPostLayout_next__3Rs3G " href="/posts/2016-10-11/multithreading-in-java" context="[object Object]">Multithreading in Java<!-- --> →</a></section></footer></article></main></div></div><script>!function(u){function e(e){for(var t,r,n=e[0],o=e[1],c=e[2],a=0,f=[];a<n.length;a++)r=n[a],l[r]&&f.push(l[r][0]),l[r]=0;for(t in o)Object.prototype.hasOwnProperty.call(o,t)&&(u[t]=o[t]);for(p&&p(e);f.length;)f.shift()();return i.push.apply(i,c||[]),d()}function d(){for(var e,t=0;t<i.length;t++){for(var r=i[t],n=!0,o=1;o<r.length;o++){var c=r[o];0!==l[c]&&(n=!1)}n&&(i.splice(t--,1),e=s(s.s=r[0]))}return e}var r={},f={25:0},l={25:0},i=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return u[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(i){var e=[];f[i]?e.push(f[i]):0!==f[i]&&{1:1,13:1}[i]&&e.push(f[i]=new Promise(function(e,n){for(var t="static/css/"+({}[i]||i)+"."+{1:"5cd5b3d4",2:"31d6cfe0",3:"31d6cfe0",4:"31d6cfe0",5:"31d6cfe0",6:"31d6cfe0",7:"31d6cfe0",8:"31d6cfe0",9:"31d6cfe0",10:"31d6cfe0",11:"31d6cfe0",12:"31d6cfe0",13:"baadcaa5",14:"31d6cfe0",15:"31d6cfe0",16:"31d6cfe0",17:"31d6cfe0",18:"31d6cfe0",19:"31d6cfe0",20:"31d6cfe0",21:"31d6cfe0",22:"31d6cfe0",23:"31d6cfe0"}[i]+".chunk.css",o=s.p+t,r=document.getElementsByTagName("link"),c=0;c<r.length;c++){var a=(u=r[c]).getAttribute("data-href")||u.getAttribute("href");if("stylesheet"===u.rel&&(a===t||a===o))return e()}var f=document.getElementsByTagName("style");for(c=0;c<f.length;c++){var u;if((a=(u=f[c]).getAttribute("data-href"))===t||a===o)return e()}var d=document.createElement("link");d.rel="stylesheet",d.type="text/css",d.onload=e,d.onerror=function(e){var t=e&&e.target&&e.target.src||o,r=new Error("Loading CSS chunk "+i+" failed.\n("+t+")");r.request=t,n(r)},d.href=o,document.getElementsByTagName("head")[0].appendChild(d)}).then(function(){f[i]=0}));var r=l[i];if(0!==r)if(r)e.push(r[2]);else{var t=new Promise(function(e,t){r=l[i]=[e,t]});e.push(r[2]=t);var n,o=document.getElementsByTagName("head")[0],c=document.createElement("script");c.charset="utf-8",c.timeout=120,s.nc&&c.setAttribute("nonce",s.nc),c.src=s.p+"static/js/"+({}[i]||i)+"."+{1:"055c2081",2:"553f2991",3:"8f1dc44d",4:"b6e18d9b",5:"4bfa3069",6:"bc5baf84",7:"f14e4bed",8:"607692a3",9:"4281e297",10:"9dfc1933",11:"0d2e2503",12:"0032c619",13:"7284ad51",14:"4f65b3d9",15:"1ad5cb3e",16:"b5a573d5",17:"da5951e9",18:"7aa5ab3a",19:"86f4bb8f",20:"c42ed917",21:"a707ecea",22:"ec77ef34",23:"fc2c0f65"}[i]+".chunk.js",n=function(e){c.onerror=c.onload=null,clearTimeout(a);var t=l[i];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),n=e&&e.target&&e.target.src,o=new Error("Loading chunk "+i+" failed.\n("+r+": "+n+")");o.type=r,o.request=n,t[1](o)}l[i]=void 0}};var a=setTimeout(function(){n({type:"timeout",target:c})},12e4);c.onerror=c.onload=n,o.appendChild(c)}return Promise.all(e)},s.m=u,s.c=r,s.d=function(e,t,r){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)s.d(r,n,function(e){return t[e]}.bind(null,n));return r},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="/",s.oe=function(e){throw console.error(e),e};var t=window.webpackJsonp=window.webpackJsonp||[],n=t.push.bind(t);t.push=e,t=t.slice();for(var o=0;o<t.length;o++)e(t[o]);var p=n;d()}([])</script><script src="/static/js/24.973fc531.chunk.js"></script><script src="/static/js/main.982b4a00.chunk.js"></script></body></html>
(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{228:function(n,a,e){"use strict";function t(n,a){if(!(n instanceof a))throw new TypeError("Cannot call a class as a function")}e.d(a,"a",function(){return t})},229:function(n,a,e){"use strict";function t(n,a){for(var e=0;e<a.length;e++){var t=a[e];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}function s(n,a,e){return a&&t(n.prototype,a),e&&t(n,e),n}e.d(a,"a",function(){return s})},230:function(n,a,e){"use strict";function t(n){return(t=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}e.d(a,"a",function(){return t})},231:function(n,a,e){"use strict";function t(n){return(t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"===typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function s(n){return(s="function"===typeof Symbol&&"symbol"===t(Symbol.iterator)?function(n){return t(n)}:function(n){return n&&"function"===typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":t(n)})(n)}function o(n,a){return!a||"object"!==s(a)&&"function"!==typeof a?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):a}e.d(a,"a",function(){return o})},232:function(n,a,e){"use strict";function t(n,a){return(t=Object.setPrototypeOf||function(n,a){return n.__proto__=a,n})(n,a)}function s(n,a){if("function"!==typeof a&&null!==a)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(a&&a.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),a&&t(n,a)}e.d(a,"a",function(){return s})},258:function(n,a,e){"use strict";e.r(a),e.d(a,"readingTime",function(){return m}),e.d(a,"default",function(){return k}),e.d(a,"tableOfContents",function(){return d}),e.d(a,"frontMatter",function(){return h});var t=e(50),s=e(228),o=e(229),p=e(231),c=e(230),r=e(232),i=e(0),l=e.n(i),u=e(73),m={text:"5 min read",minutes:4.3,time:258e3,words:860},k=function(n){function a(n){var e;return Object(s.a)(this,a),(e=Object(p.a)(this,Object(c.a)(a).call(this,n))).layout=null,e}return Object(r.a)(a,n),Object(o.a)(a,[{key:"render",value:function(){var n=this.props,a=n.components;Object(t.a)(n,["components"]);return l.a.createElement(u.MDXTag,{name:"wrapper",components:a},l.a.createElement("div",null,l.a.createElement(u.MDXTag,{name:"p",components:a},"Today I\u2019m going to talk about ",l.a.createElement(u.MDXTag,{name:"strong",components:a,parentName:"p"},"thread synchronization"),". Let\u2019s start with writing a simple multi-threaded counter."),l.a.createElement(u.MDXTag,{name:"pre",components:a},l.a.createElement(u.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"language-java","data-language":"java","data-highlighted-line-numbers":"",dangerouslySetInnerHTML:{__html:'<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CounterThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token class-name">CounterThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread:%s, counter:%d\\\\n"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            count<span class="token operator">++</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span>\\<span class="token punctuation">[</span>\\<span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterThread</span><span class="token punctuation">(</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CounterThread</span><span class="token punctuation">(</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n'}}})),l.a.createElement(u.MDXTag,{name:"p",components:a},"We expect to see a nice incrementation of the count variable, sometimes by the thread 1 and sometimes by the thread 2. Here is the output this code produces:"),l.a.createElement(u.MDXTag,{name:"pre",components:a},l.a.createElement(u.MDXTag,{name:"code",components:a,parentName:"pre",props:{}},"Thread:t2, counter:0\nThread:t1, counter:0\nThread:t1, counter:2\nThread:t1, counter:3\nThread:t1, counter:4\nThread:t1, counter:5\nThread:t2, counter:1\nThread:t2, counter:7\nThread:t2, counter:8\nThread:t2, counter:9\nThread:t1, counter:6\n")),l.a.createElement(u.MDXTag,{name:"p",components:a},"This is definitely not the outcome we expected. What is wrong with those first 2 lines? Thread ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"t2")," increases the counter to 1, so the second line should\u2019ve been ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"Thread:t1, counter:1"),", right?"),l.a.createElement(u.MDXTag,{name:"p",components:a},l.a.createElement(u.MDXTag,{name:"strong",components:a,parentName:"p"},"NO"),"."),l.a.createElement(u.MDXTag,{name:"p",components:a},"In the example above, there is the possibility that both threads access the variable and increment it at the same time. It\u2019s called ",l.a.createElement(u.MDXTag,{name:"strong",components:a,parentName:"p"},"race condition"),". Because the thread scheduling algorithm can swap between threads at any time; we don\u2019t know the execution order of the threads, and we don\u2019t know when they will try to access the shared data. The result is; multiple threads ",l.a.createElement(u.MDXTag,{name:"em",components:a,parentName:"p"},"racing")," to access and change the data."),l.a.createElement(u.MDXTag,{name:"p",components:a},"There are many ways to overcome this problem. Here I\u2019ll provide you two of them that I use the most."),l.a.createElement(u.MDXTag,{name:"h3",components:a,props:{id:"monitors"}},"Monitors"),l.a.createElement(u.MDXTag,{name:"p",components:a},"In Java, synchronization is built around an internal entity of an object known as ",l.a.createElement(u.MDXTag,{name:"em",components:a,parentName:"p"},"intrinsic lock")," or ",l.a.createElement(u.MDXTag,{name:"em",components:a,parentName:"p"},"monitor"),". Every object has an intrinsic lock associated with it, and Java uses that to synchronize the object."),l.a.createElement(u.MDXTag,{name:"p",components:a},"If you want to prevent your threads from accessing the shared data at the same time, you can simply use the builtin synchronized keyword."),l.a.createElement(u.MDXTag,{name:"pre",components:a},l.a.createElement(u.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"language-java","data-language":"java","data-highlighted-line-numbers":"",dangerouslySetInnerHTML:{__html:'<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CounterThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">CounterThread</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread:%s, counter:%d\\\\n"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                count<span class="token operator">++</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n'}}})),l.a.createElement(u.MDXTag,{name:"p",components:a},"The lock object here acts as a physical lock. Whenever a thread accesses the synchronized code:"),l.a.createElement(u.MDXTag,{name:"ul",components:a},l.a.createElement(u.MDXTag,{name:"li",components:a,parentName:"ul"},"If the lock is unlocked, Java automatically locks it and allows the thread to run the code. When the thread finishes its job, Java automatically unlocks the lock."),l.a.createElement(u.MDXTag,{name:"li",components:a,parentName:"ul"},"If it\u2019s locked, thread just waits its turn.")),l.a.createElement(u.MDXTag,{name:"p",components:a},"Here we used a simple ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"Object")," as a lock, but Java provides more powerful locks in the ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"java.util.concurrent.locks")," package. You can check them out if you want."),l.a.createElement(u.MDXTag,{name:"p",components:a},"We can also use the ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"synchronized")," keyword on the method itself, like this:"),l.a.createElement(u.MDXTag,{name:"pre",components:a},l.a.createElement(u.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"language-java","data-language":"java","data-highlighted-line-numbers":"",dangerouslySetInnerHTML:{__html:'<span class="token annotation punctuation">@Override</span>\n<span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread:%s, counter:%d\\\\n"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        count<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n'}}})),l.a.createElement(u.MDXTag,{name:"p",components:a},"But, ",l.a.createElement(u.MDXTag,{name:"strong",components:a,parentName:"p"},"it won\u2019t work")," with our case. Here is the output:"),l.a.createElement(u.MDXTag,{name:"pre",components:a},l.a.createElement(u.MDXTag,{name:"code",components:a,parentName:"pre",props:{}},"Thread:t1, counter:0\nThread:t2, counter:0\nThread:t2, counter:2\nThread:t2, counter:3\nThread:t2, counter:4\nThread:t2, counter:5\nThread:t2, counter:6\nThread:t2, counter:7\nThread:t2, counter:8\nThread:t2, counter:9\nThread:t1, counter:1\n")),l.a.createElement(u.MDXTag,{name:"p",components:a},"If we synchronize the method, Java uses the object\u2019s lock. But our threads have their own objects, and ",l.a.createElement(u.MDXTag,{name:"strong",components:a,parentName:"p"},"have their own locks"),". Here, they don\u2019t really do anything but locking and unlocking two separate locks without knowing about each other. It becomes the same thing as using no locks at all. It only would\u2019ve worked if the threads were trying to access the same object."),l.a.createElement(u.MDXTag,{name:"h3",components:a,props:{id:"atomic-operations-and-volatile-keyword"}},"Atomic Operations and Volatile Keyword"),l.a.createElement(u.MDXTag,{name:"p",components:a},"An operation is ",l.a.createElement(u.MDXTag,{name:"em",components:a,parentName:"p"},"atomic"),", (or ",l.a.createElement(u.MDXTag,{name:"em",components:a,parentName:"p"},"linearizable"),", ",l.a.createElement(u.MDXTag,{name:"em",components:a,parentName:"p"},"indivisible"),", ",l.a.createElement(u.MDXTag,{name:"em",components:a,parentName:"p"},"uninterruptible"),") if it appears to the rest of the system to occur instantaneously. An atomic operation cannot stop in the middle: ",l.a.createElement(u.MDXTag,{name:"strong",components:a,parentName:"p"},"it either happens completely, or it doesn\u2019t happen at all"),". In other words, ",l.a.createElement(u.MDXTag,{name:"a",components:a,parentName:"p",props:{href:"http://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect"}},"side effects")," of an atomic operation are not visible until it finishes."),l.a.createElement(u.MDXTag,{name:"p",components:a},"By default, ",l.a.createElement(u.MDXTag,{name:"a",components:a,parentName:"p",props:{href:"https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html"}},l.a.createElement(u.MDXTag,{name:"strong",components:a,parentName:"a"},"Java guarantees that reading or writing a variable is an atomic operation")),", unless the variable is a long or double. If the variable is declared as volatile, reads and writes become atomic even if it\u2019s a ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"long")," or ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"double"),"."),l.a.createElement(u.MDXTag,{name:"p",components:a},"So, why didn\u2019t our example ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"count++")," work in the first place? The reason is ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"++")," decomposes into 3 operations; reading, incrementing, and writing back. Even though they\u2019re atomic by themselves, it doesn\u2019t prevent a thread from reading the variable while the other thread is incrementing it. To overcome this problem, we can use the atomic implementation of the integer primitive: ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"AtomicInteger"),". It provides atomic versions of some composite operations, such as ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"getAndIncrement()"),", ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"incrementAndGet()")," and ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"getAndSet(value)"),"."),l.a.createElement(u.MDXTag,{name:"pre",components:a},l.a.createElement(u.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"language-java","data-language":"java","data-highlighted-line-numbers":"",dangerouslySetInnerHTML:{__html:'<span class="token annotation punctuation">@Override</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread:%s, counter:%d\\\\n"</span><span class="token punctuation">,</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n'}}})),l.a.createElement(u.MDXTag,{name:"p",components:a},"Here\u2019s the output:"),l.a.createElement(u.MDXTag,{name:"pre",components:a},l.a.createElement(u.MDXTag,{name:"code",components:a,parentName:"pre",props:{}},"Thread:t1, counter:0\nThread:t2, counter:1\nThread:t2, counter:3\nThread:t2, counter:4\nThread:t2, counter:5\nThread:t2, counter:6\nThread:t2, counter:7\nThread:t2, counter:8\nThread:t2, counter:9\nThread:t1, counter:2\n")),l.a.createElement(u.MDXTag,{name:"p",components:a},"As you can see, even though both of them could enter the while loop, they couldn\u2019t increase the number at the same time. There are atomic implementations of many primitives. You can find them under the ",l.a.createElement(u.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"java.util.concurrent.atomic")," package."),l.a.createElement(u.MDXTag,{name:"p",components:a},"Next time I\u2019ll be talking about ",l.a.createElement(u.MDXTag,{name:"strong",components:a,parentName:"p"},"semaphores"),", which allows us to have (at most) N number of threads accessing the same shared state at the same time. Have a great day!")))}}]),a}(l.a.Component),d=function(){arguments.length>0&&void 0!==arguments[0]&&arguments[0];return[{id:"monitors",level:3,title:"Monitors",children:[]},{id:"atomic-operations-and-volatile-keyword",level:3,title:"Atomic Operations and Volatile Keyword",children:[]}]},h={}}}]);
//# sourceMappingURL=26.e4580985.chunk.js.map